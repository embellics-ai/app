  // Get analytics from Retell AI (PROTECTED)
  router.get(
    '/retell',
    requireAuth,
    requireClientAdmin,
    async (req: AuthenticatedRequest, res) => {
      try {
        // Validate tenant ID exists in token
        const tenantId = assertTenant(req, res);
        if (!tenantId) return;

        // Get tenant's widget config to find their Retell API key
        const widgetConfig = await storage.getWidgetConfig(tenantId);

        // If no widget config or no API key configured, return empty analytics
        if (!widgetConfig?.retellApiKey) {
          console.log(`[Analytics] No Retell API key configured for tenant: ${tenantId}`);
          return res.json({
            totalCalls: 0,
            completedCalls: 0,
            averageDuration: 0,
            averageLatency: 0,
            successRate: 0,
            sentimentBreakdown: {
              Positive: 0,
              Negative: 0,
              Neutral: 0,
              Unknown: 0,
            },
            disconnectionReasons: {},
            callStatusBreakdown: {},
            callsOverTime: [],
            directionBreakdown: { inbound: 0, outbound: 0 },
          });
        }

        // Create a Retell client using the tenant's own API key
        const tenantRetellClient = new Retell({
          apiKey: widgetConfig.retellApiKey,
        });

        // Get time range from query params (default to all time)
        const { start_date, end_date } = req.query;

        // Build filter for time range (NO agent_id filter - we want ALL agents in this account)
        const filter: any = {};

        // Add time filtering if provided
        if (start_date) {
          filter.start_timestamp = {
            gte: new Date(start_date as string).getTime(),
          };
        }
        if (end_date) {
          filter.start_timestamp = {
            ...filter.start_timestamp,
            lte: new Date(end_date as string).getTime(),
          };
        }

        let calls: any[] = [];
        let agentNames: Record<string, string> = {}; // Declare in outer scope

        console.log(`[Analytics] Fetching account-wide calls for tenant: ${tenantId}`);
        console.log(`[Analytics] Filter criteria:`, JSON.stringify(filter, null, 2));

        try {
          // First, fetch list of active (non-deleted) agents and store their names
          let activeAgentIds: Set<string>;
          try {
            const activeAgents = await tenantRetellClient.agent.list();
            activeAgentIds = new Set(activeAgents.map((agent: any) => agent.agent_id));
            activeAgents.forEach((agent: any) => {
              if (agent.agent_id && agent.agent_name) {
                agentNames[agent.agent_id] = agent.agent_name;
              }
            });
            console.log(`[Analytics] Found ${activeAgentIds.size} active agents in account`);
          } catch (agentError) {
            console.warn(
              `[Analytics] Could not fetch agent list, including all calls:`,
              agentError,
            );
            activeAgentIds = new Set(); // Empty set means we'll include all calls
          }

          // Fetch ALL calls from tenant's Retell account with pagination
          // Retell uses pagination_key (last call_id) for pagination
          let paginationKey: string | undefined = undefined;
          let pageCount = 0;
          const maxLimit = 1000; // Retell's max limit per request

          do {
            pageCount++;
            const pageParams: any = {
              filter_criteria: Object.keys(filter).length > 0 ? filter : undefined,
              limit: maxLimit,
              sort_order: 'descending', // Most recent first
            };

            if (paginationKey) {
              pageParams.pagination_key = paginationKey;
            }

            console.log(
              `[Analytics] Fetching page ${pageCount} with params:`,
              JSON.stringify({ limit: maxLimit, has_pagination_key: !!paginationKey }, null, 2),
            );

            const response: any = await tenantRetellClient.call.list(pageParams);

            // Retell returns an array of calls
            if (Array.isArray(response) && response.length > 0) {
              calls.push(...response);
              console.log(
                `[Analytics] Page ${pageCount}: Fetched ${response.length} calls (total so far: ${calls.length})`,
              );

              // If we got the max limit, there might be more pages
              // Use the last call's ID as pagination key for next request
              if (response.length === maxLimit) {
                const lastCall = response[response.length - 1];
                paginationKey = lastCall.call_id;
                console.log(
                  `[Analytics] More pages available, next pagination_key: ${paginationKey}`,
                );
              } else {
                // Got fewer than max limit, this is the last page
                paginationKey = undefined;
                console.log(`[Analytics] Last page reached (got ${response.length} < ${maxLimit})`);
              }
            } else {
              // Empty response or not an array
              paginationKey = undefined;
              console.log(`[Analytics] No more calls to fetch`);
            }

            // Safety limit: prevent infinite loops (max 100 pages = 100,000 calls)
            if (pageCount >= 100) {
              console.warn(
                `[Analytics] Reached pagination safety limit (100 pages, ${calls.length} total calls)`,
              );
              break;
            }
          } while (paginationKey);

          console.log(
            `[Analytics] ✓ Fetched ${calls.length} total calls across ${pageCount} pages`,
          );

          // Filter out calls from deleted agents (if we successfully fetched agent list)
          if (activeAgentIds.size > 0) {
            const callsBeforeFilter = calls.length;
            calls = calls.filter((call: any) => activeAgentIds.has(call.agent_id));
            const callsRemoved = callsBeforeFilter - calls.length;

            if (callsRemoved > 0) {
              console.log(`[Analytics] Filtered out ${callsRemoved} calls from deleted agents`);
              console.log(
                `[Analytics] Remaining: ${calls.length} calls from ${activeAgentIds.size} active agents`,
              );
            }
          }

          // Filter by date range manually (Retell API doesn't respect filter_criteria for dates)
          if (Object.keys(filter).length > 0 && filter.start_timestamp) {
            const beforeDateFilter = calls.length;
            calls = calls.filter((call: any) => {
              if (!call.start_timestamp) return false;

              if (filter.start_timestamp.gte && call.start_timestamp < filter.start_timestamp.gte) {
                return false;
              }
              if (filter.start_timestamp.lte && call.start_timestamp > filter.start_timestamp.lte) {
                return false;
              }
              return true;
            });

            const dateFiltered = beforeDateFilter - calls.length;
            if (dateFiltered > 0) {
              console.log(
                `[Analytics] Filtered out ${dateFiltered} calls outside date range (${beforeDateFilter} → ${calls.length})`,
              );
            }
          }

          if (calls.length > 0) {
            const agentIds = Array.from(new Set(calls.map((c: any) => c.agent_id)));
            console.log(
              `[Analytics] Final dataset: ${calls.length} calls across ${agentIds.length} agents:`,
              agentIds,
            );

            // Log call status breakdown to debug discrepancies
            const statusCounts: Record<string, number> = {};
            const typeCounts: Record<string, number> = {};
            const directionCounts: Record<string, number> = {};

            calls.forEach((call: any) => {
              const status = call.call_status || 'unknown';
              statusCounts[status] = (statusCounts[status] || 0) + 1;

              const type = call.call_type || 'unknown';
              typeCounts[type] = (typeCounts[type] || 0) + 1;

              const direction = call.direction || 'unknown';
              directionCounts[direction] = (directionCounts[direction] || 0) + 1;
            });

            console.log(`[Analytics] Call status breakdown:`, statusCounts);
            console.log(`[Analytics] Call type breakdown:`, typeCounts);
            console.log(`[Analytics] Call direction breakdown:`, directionCounts);

            // Check for calls with zero/null duration (might be filtered by Retell)
            const zeroDurationCalls = calls.filter(
              (c: any) => !c.duration_ms || c.duration_ms === 0,
            );
            if (zeroDurationCalls.length > 0) {
              console.log(
                `[Analytics] Found ${zeroDurationCalls.length} calls with zero/null duration`,
              );
            }

            // Check web_call vs phone_call
            const webCalls = calls.filter((c: any) => c.call_type === 'web_call');
            console.log(
              `[Analytics] Web calls: ${webCalls.length}, Phone calls: ${
                calls.length - webCalls.length
              }`,
            );

            // Check date range of actual calls received
            if (calls.length > 0) {
              const timestamps = calls
                .map((c: any) => c.start_timestamp)
                .filter(Boolean)
                .sort((a, b) => a - b);
              if (timestamps.length > 0) {
                const earliest = new Date(timestamps[0]).toISOString();
                const latest = new Date(timestamps[timestamps.length - 1]).toISOString();
                console.log(`[Analytics] Actual call date range: ${earliest} to ${latest}`);
              }
            }
          }
        } catch (retellError: any) {
          console.error('[Retell] Error fetching calls:', retellError);
          console.error('[Retell] Error details:', JSON.stringify(retellError, null, 2));
          console.error('[Retell] Error message:', retellError.message);
          // Return empty analytics if Retell API fails (don't break the dashboard)
          return res.json({
            totalCalls: 0,
            completedCalls: 0,
            averageDuration: 0,
            averageLatency: 0,
            successRate: 0,
            sentimentBreakdown: {
              Positive: 0,
              Negative: 0,
              Neutral: 0,
              Unknown: 0,
            },
            disconnectionReasons: {},
            callStatusBreakdown: {},
            callsOverTime: [],
            directionBreakdown: { inbound: 0, outbound: 0 },
          });
        }

        // Aggregate analytics data
        let totalDuration = 0;
        let totalLatency = 0;
        let successfulCalls = 0;
        let completedCalls = 0;
        let pickedUpCalls = 0;
        let transferredCalls = 0;
        let voicemailCalls = 0;

        const sentimentCounts: Record<string, number> = {};
        const disconnectionReasons: Record<string, number> = {};
        const callStatusBreakdown: Record<string, number> = {};
        const callsByDate: Record<string, number> = {};
        const directionBreakdown: Record<string, number> = {
          inbound: 0,
          outbound: 0,
        };

        // Additional tracking for charts
        const callsByDateStacked: Record<string, any> = {};
        const agentMetrics: Record<string, any> = {};

        for (const call of calls) {
          const agentId = call.agent_id;
          const dateKey = call.start_timestamp
            ? new Date(call.start_timestamp).toISOString().split('T')[0]
            : 'unknown';

          // Initialize agent metrics if not exists
          if (agentId && !agentMetrics[agentId]) {
            agentMetrics[agentId] = {
              totalCalls: 0,
              successfulCalls: 0,
              pickedUpCalls: 0,
              transferredCalls: 0,
              voicemailCalls: 0,
            };
          }

          // Initialize date metrics if not exists
          if (!callsByDateStacked[dateKey]) {
            callsByDateStacked[dateKey] = {
              successful: 0,
              unsuccessful: 0,
              agentHangup: 0,
              callTransfer: 0,
              userHangup: 0,
              otherDisconnection: 0,
              positive: 0,
              neutral: 0,
              negative: 0,
              otherSentiment: 0,
            };
          }

          // Count call status
          if (call.call_status) {
            callStatusBreakdown[call.call_status] =
              (callStatusBreakdown[call.call_status] || 0) + 1;
          }

          // Count direction (for all calls, not just completed)
          if (call.direction) {
            directionBreakdown[call.direction] = (directionBreakdown[call.direction] || 0) + 1;
          }

          // Track all calls metrics (not just ended)
          if (agentId) {
            agentMetrics[agentId].totalCalls++;
          }

          // Only analyze completed calls
          if (call.call_status === 'ended') {
            completedCalls++;

            // Duration
            if (call.duration_ms) {
              totalDuration += call.duration_ms;
            }

            // Latency (use e2e p50 if available)
            if (call.latency?.e2e?.p50) {
              totalLatency += call.latency.e2e.p50;
            }

            // Success rate (call_successful)
            const isSuccessful = call.call_analysis?.call_successful === true;
            if (isSuccessful) {
              successfulCalls++;
              if (agentId) agentMetrics[agentId].successfulCalls++;
              callsByDateStacked[dateKey].successful++;
            } else {
              callsByDateStacked[dateKey].unsuccessful++;
            }

            // Pickup rate (if call was answered/picked up)
            // A call is picked up if it wasn't disconnected before being answered
            if (
              call.disconnection_reason !== 'voicemail' &&
              call.disconnection_reason !== 'no_answer'
            ) {
              pickedUpCalls++;
              if (agentId) agentMetrics[agentId].pickedUpCalls++;
            }

            // Transfer rate
            if (call.disconnection_reason === 'call_transfer') {
              transferredCalls++;
              if (agentId) agentMetrics[agentId].transferredCalls++;
              callsByDateStacked[dateKey].callTransfer++;
            }

            // Voicemail rate
            if (call.disconnection_reason === 'voicemail') {
              voicemailCalls++;
              if (agentId) agentMetrics[agentId].voicemailCalls++;
            }

            // Sentiment
            const sentiment = call.call_analysis?.user_sentiment || 'unknown';
            sentimentCounts[sentiment] = (sentimentCounts[sentiment] || 0) + 1;

            // Sentiment by date for stacked chart
            if (sentiment === 'positive') {
              callsByDateStacked[dateKey].positive++;
            } else if (sentiment === 'neutral') {
              callsByDateStacked[dateKey].neutral++;
            } else if (sentiment === 'negative') {
              callsByDateStacked[dateKey].negative++;
            } else {
              callsByDateStacked[dateKey].otherSentiment++;
            }

            // Disconnection reason
            const disconnectReason = call.disconnection_reason || 'unknown';
            disconnectionReasons[disconnectReason] =
              (disconnectionReasons[disconnectReason] || 0) + 1;

            // Disconnection by date for stacked chart
            if (disconnectReason === 'agent_hangup') {
              callsByDateStacked[dateKey].agentHangup++;
            } else if (disconnectReason === 'user_hangup') {
              callsByDateStacked[dateKey].userHangup++;
            } else if (disconnectReason !== 'call_transfer') {
              callsByDateStacked[dateKey].otherDisconnection++;
            }

            // Calls over time
            if (call.start_timestamp) {
              const date = new Date(call.start_timestamp).toISOString().split('T')[0];
              callsByDate[date] = (callsByDate[date] || 0) + 1;
            }
          }
        }

        // Calculate averages
        const averageDuration = completedCalls > 0 ? totalDuration / completedCalls : 0;
        const averageLatency = completedCalls > 0 ? totalLatency / completedCalls : 0;
        const successRate = completedCalls > 0 ? (successfulCalls / completedCalls) * 100 : 0;
        const pickupRate = completedCalls > 0 ? (pickedUpCalls / completedCalls) * 100 : 0;
        const transferRate = completedCalls > 0 ? (transferredCalls / completedCalls) * 100 : 0;
        const voicemailRate = completedCalls > 0 ? (voicemailCalls / completedCalls) * 100 : 0;

        // Format sentiment breakdown as percentages
        const sentimentBreakdown: Record<string, number> = {};
        for (const [sentiment, count] of Object.entries(sentimentCounts)) {
          sentimentBreakdown[sentiment] = completedCalls > 0 ? (count / completedCalls) * 100 : 0;
        }

        // Calculate per-date metrics for time-series charts
        const dailyMetrics: Record<string, any> = {};

        for (const call of calls) {
          if (call.call_status !== 'ended') continue;

          const dateKey = call.start_timestamp
            ? new Date(call.start_timestamp).toISOString().split('T')[0]
            : 'unknown';

          if (!dailyMetrics[dateKey]) {
            dailyMetrics[dateKey] = {
              totalCalls: 0,
              successfulCalls: 0,
              pickedUpCalls: 0,
              transferredCalls: 0,
              voicemailCalls: 0,
              totalDuration: 0,
              totalLatency: 0,
              callsWithLatency: 0,
            };
          }

          dailyMetrics[dateKey].totalCalls++;

          if (call.call_analysis?.call_successful) {
            dailyMetrics[dateKey].successfulCalls++;
          }

          if (
            call.disconnection_reason !== 'voicemail' &&
            call.disconnection_reason !== 'no_answer'
          ) {
